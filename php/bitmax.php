<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;

class bitmax extends Exchange {

    public function describe() {
        // There are cash/margin/futures accounts for each bitmax user.
        // You could provide it when call the api => params = array('account' => 'cash'/'margin'/'futures');
        // or you can set in advance by calling setAccount(account), where account is one of 'cash'/'margin'/'futures'.
        // e.g.  bitmax.createOrder('BTC-PERP', 'limit', 'buy', 0.01, 7125, params = array('account':'futures'))
        // or bitmax.setAccount('futures')
        return $this->deep_extend(parent::describe (), array(
            'id' => 'bitmax',
            'name' => 'BitMax',
            'countries' => array( 'CN' ), // China
            'rateLimit' => 500,
            'certified' => false,
            // new metainfo interface
            'has' => array(
                'CORS' => false,
                'fetchAccounts' => true,
                'fetchTickers' => true,
                'fetchOHLCV' => true,
                'fetchMyTrades' => false,
                'fetchOrder' => true,
                'fetchOrders' => true,
                'fetchOpenOrders' => true,
                'fetchOrderTrades' => false,
                'fetchClosedOrders' => true,
                'fetchTransactions' => false,
                'fetchCurrencies' => true,
                'cancelAllOrders' => true,
                'fetchDepositAddress' => true,
            ),
            'timeframes' => array(
                '1m' => '1',
                '3m' => '3',
                '5m' => '5',
                '15m' => '15',
                '30m' => '30',
                '1h' => '60',
                '2h' => '120',
                '4h' => '240',
                '6h' => '360',
                '12h' => '720',
                '1d' => '1d',
                '1w' => '1w',
                '1M' => '1m',
            ),
            'version' => 'v1',
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/66820319-19710880-ef49-11e9-8fbe-16be62a11992.jpg',
                'api' => 'https://bitmax.io',
                'test' => 'https://bitmax-test.io/api',
                'www' => 'https://bitmax.io',
                'doc' => array(
                    'https://bitmax-exchange.github.io/bitmax-pro-api/#rest-apis',
                ),
                'fees' => 'https://bitmax.io/#/feeRate/tradeRate',
                'referral' => 'https://bitmax.io/#/register?inviteCode=T6J9R0EB',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'assets',
                        'barhist',
                        'barhist/info',
                        'cash/assets',
                        'cash/products',
                        'depth',
                        'fees',
                        'futures/collateral',
                        'futures/contracts',
                        'depth',
                        'margin/assets',
                        'margin/products',
                        'margin/ref-price',
                        'trades',
                        'products',
                        'ticker',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'cash/balance',
                        'cash/order/hist/current',
                        'cash/order/open',
                        'cash/order/status',
                        'futures/balance',
                        'futures/order/hist/current',
                        'futures/order/open',
                        'futures/order/status',
                        'margin/balance',
                        'margin/order/hist/current',
                        'margin/order/open',
                        'margin/order/status',
                        'margin/risk',
                        'order/hist',
                        'transaction',
                        'info',
                        'wallet/deposit/address',
                    ),
                    'post' => array(
                        'cash/order',
                        'cash/order/batch',
                        'futures/order',
                        'futures/order/batch',
                        'margin/order',
                        'margin/order/batch',
                    ),
                    'delete' => array(
                        'cash/order',
                        'cash/order/all',
                        'cash/order/batch',
                        'margin/order',
                        'margin/order/all',
                        'margin/order/batch',
                        'futures/order',
                        'futures/order/all',
                        'futures/order/batch',
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => true,
                    'percentage' => true,
                    'taker' => 0.001,
                    'maker' => 0.001,
                ),
            ),
            'options' => array(
                'account' => 'cash', // 'cash'/'margin'/'futures'
                'accountGroup' => null,
                'parseOrderToPrecision' => false,
            ),
            'exceptions' => array(
                'exact' => array(
                    // TODO => fix error code mapping
                    '2100' => '\\ccxt\\AuthenticationError', // array("code":2100,"message":"ApiKeyFailure")
                    '5002' => '\\ccxt\\BadSymbol', // array("code":5002,"message":"Invalid Symbol")
                    '6001' => '\\ccxt\\BadSymbol', // array("code":6001,"message":"Trading is disabled on symbol.")
                    '6010' => '\\ccxt\\InsufficientFunds', // array('code' => 6010, 'message' => 'Not enough balance.')
                    '60060' => '\\ccxt\\InvalidOrder', // array( 'code' => 60060, 'message' => 'The order is already filled or canceled.' )
                    '600503' => '\\ccxt\\InvalidOrder', // array("code":600503,"message":"Notional is too small.")
                ),
                'broad' => array(),
            ),
            'commonCurrencies' => array(
                'BTCBEAR' => 'BEAR',
                'BTCBULL' => 'BULL',
            ),
        ));
    }

    public function get_valid_accounts() {
        // Bitmax sub-account
        return ['cash', 'margin', 'futures'];
    }

    public function get_account($params = array ()) {
        // get current or provided bitmax sub-$account
        $account = $this->safe_value($params, 'account', $this->options['account']);
        return strtolower($account).capitalize ();
    }

    public function set_account($account) {
        // set default bitmax sub-$account
        $validAccounts = $this->get_valid_accounts();
        if (is_array($validAccounts) && array_key_exists($account, $validAccounts)) {
            $this->options['account'] = $account;
        }
    }

    public function get_futures_collateral($params = array ()) {
        // futures collateral
        $response = $this->publicGetFuturesCollateral ($params);
        return $this->safe_value($response, 'data', array());
    }

    public function fetch_currencies($params = array ()) {
        $response = $this->publicGetAssets ($params);
        //
        // {
        //    "$code" => 0,
        //    "data" => array(
        //        {
        //            "assetCode" => "ONG",
        //            "assetName" => "ONG",
        //            "precisionScale" => 9,
        //            "nativeScale" => 3,
        //            "withdrawalFee" => "1.0",
        //            "minWithdrawalAmt" => "2.0",
        //            "$status" => "Normal"
        //        }
        //    )
        // }
        //
        $result = array();
        if ($this->safe_value($response, 'code', -1) !== 0) {
            return $result;
        }
        $records = $this->safe_value($response, 'data', array());
        for ($i = 0; $i < count($records); $i++) {
            $currency = $records[$i];
            $id = $this->safe_string($currency, 'assetCode');
            // todo => will need to rethink the fees
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            $code = $this->safe_currency_code($id);
            $precision = $this->safe_integer($currency, 'precisionScale');
            $fee = $this->safe_float($currency, 'withdrawalFee'); // todo => redesign
            $status = $this->safe_string($currency, 'status');
            $active = ($status === 'Normal');
            $result[$code] = array(
                'id' => $id,
                'code' => $code,
                'info' => $currency,
                'type' => null,
                'name' => $this->safe_string($currency, 'assetName'),
                'active' => $active,
                // Todo => tiered $fee make $fee calculation complicated now. To provide separate $fee related method.
                'fee' => $fee,
                'precision' => $precision,
                'limits' => array(
                    'amount' => array(
                        'min' => pow(10, -$precision),
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => pow(10, -$precision),
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => $this->safe_float($currency, 'minWithdrawalAmt'),
                        'max' => null,
                    ),
                ),
            );
        }
        return $result;
    }

    public function fetch_markets($params = array ()) {
        $response = $this->publicGetProducts ($params);
        //
        // {
        //    "code" => 0,
        //    "data" => array(
        //        {
        //            "$symbol" => "DAD/USDT",
        //            "baseAsset" => "DAD",
        //            "quoteAsset" => "USDT",
        //            "$status" => "Normal",
        //            "minNotional" => "5",
        //            "maxNotional" => "50000",
        //            "marginTradable" => False,
        //            "commissionType" => "Quote",
        //            "commissionReserveRate" => "0.001",
        //            "tickSize" => "0.00001",
        //            "lotSize" => "1"
        //        }
        //    )
        // }
        //
        $result = array();
        if ($this->safe_value($response, 'code', -1) !== 0) {
            return $result;
        }
        $records = $this->safe_value($response, 'data', array());
        for ($i = 0; $i < count($records); $i++) {
            $market = $records[$i];
            $id = $this->safe_string($market, 'symbol');
            $baseId = $this->safe_string($market, 'baseAsset');
            $quoteId = $this->safe_string($market, 'quoteAsset');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $id; // $base . '/' . $quote;
            $precision = array(
                'amount' => $this->precision_from_string($this->safe_string($market, 'lotSize')),
                'price' => $this->precision_from_string($this->safe_string($market, 'tickSize')),
            );
            $status = $this->safe_string($market, 'status');
            $active = ($status === 'Normal');
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'info' => $market,
                'active' => $active,
                'precision' => $precision,
                'limits' => array(
                    'amount' => array(
                        'min' => $this->safe_float($market, 'lotSize'),
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => $this->safe_float($market, 'tickSize'),
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => $this->safe_float($market, 'minNotional'),
                        'max' => $this->safe_float($market, 'maxNotional'),
                    ),
                ),
            );
        }
        return $result;
    }

    public function calculate_fee($symbol, $type, $side, $amount, $price, $takerOrMaker = 'taker', $params = array ()) {
        // TODO => fee calculation here is incorrect, we need to support tiered fee calculation.
        $market = $this->markets[$symbol];
        $key = 'quote';
        $rate = $market[$takerOrMaker];
        $cost = $amount * $rate;
        $precision = $market['precision']['price'];
        if ($side === 'sell') {
            $cost *= $price;
        } else {
            $key = 'base';
            $precision = $market['precision']['amount'];
        }
        $cost = $this->decimal_to_precision($cost, ROUND, $precision, $this->precisionMode);
        return array(
            'type' => $takerOrMaker,
            'currency' => $market[$key],
            'rate' => $rate,
            'cost' => floatval ($cost),
        );
    }

    public function fetch_accounts($params = array ()) {
        $accountGroup = $this->safe_string($this->options, 'accountGroup');
        $records = null;
        if ($accountGroup === null) {
            $response = $this->privateGetInfo ($params);
            //
            // {
            //    'code' => 0,
            //    'data':
            //        {
            //            'email' => 'xxxcc@gmail.com',
            //            'accountGroup' => 5,
            //            'viewPermission' => True,
            //            'tradePermission' => True,
            //            'transferPermission' => True,
            //            'withdrawPermission' => True,
            //            'cashAccount' => ['xxxxxxxxxxxxxxxxxxxxxxxxxx'],
            //            'marginAccount' => ['yyyyyyyyyyyyyyyyyyyyyyyyy'],
            //            'futuresAccount' => ['zzzzzzzzzzzzzzzzzzzzzzzzz'],
            //            'userUID' => 'U123456789'
            //        }
            // }
            //
            if ($response['code'] === 0) {
                $records = $response['data'];
                $accountGroup = $this->safe_string($records, 'accountGroup');
                $this->options['accountGroup'] = $accountGroup;
            }
        }
        return array(
            array(
                'id' => $accountGroup,
                'type' => null,
                'currency' => null,
                'info' => $records,
            ),
        );
    }

    public function fetch_balance($params = array ()) {
        $this->load_markets();
        $this->load_accounts();
        $method = 'privateGet' . $this->get_account($params) . 'Balance';
        $response = $this->$method ($params);
        //
        // {
        //    'code' => 0,
        //    'data':
        //        array(
        //            array(
        //                'asset' => 'BCHSV',
        //                'totalBalance' => '64.298000048',
        //                'availableBalance' => '64.298000048'
        //            ),
        //         )
        // }
        //
        $result = array( 'info' => $response );
        $balances = $this->safe_value($response, 'data', array());
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $code = $this->safe_currency_code($this->safe_string($balance, 'asset'));
            $account = $this->account();
            $account['free'] = $this->safe_float($balance, 'availableBalance');
            $account['total'] = $this->safe_float($balance, 'totalBalance');
            $account['used'] = $account['total'] - $account['free'];
            $result[$code] = $account;
        }
        return $this->parse_balance($result);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['n'] = $limit; // default = maximum = 100
        }
        $response = $this->publicGetDepth (array_merge($request, $params));
        //
        // {
        //    "code" => 0,
        //    "$data" => {
        //        "m" => "depth-snapshot",
        //        "$symbol" => "BTC/USDT",
        //        "$data" => {
        //            "ts" => 1583558793465,
        //            "seqnum" => 8273359781,
        //            "asks" => array(
        //                array(
        //                    "9082.73",
        //                    "1.31752"
        //                ),
        //                array(
        //                    "9082.76",
        //                    "0.00342"
        //                )
        //            ),
        //            "bids" => array(
        //                array(
        //                    "5532.27",
        //                    "0.00606"
        //                ),
        //                array(
        //                    "4858.54",
        //                    "0.02789"
        //                )
        //            )
        //        }
        //    }
        // }
        //
        $data = $this->safe_value($response, 'data', array());
        $records = $this->safe_value($data, 'data', array());
        $timestamp = $this->safe_integer($records, 'ts');
        $result = $this->parse_order_book($records, $timestamp);
        $result['nonce'] = $this->safe_integer($records, 'seqnum');
        return $result;
    }

    public function parse_ticker($ticker, $market = null) {
        //
        // {
        //    'symbol' => 'BTC/USDT',
        //    'open' => '8086.63',
        //    'close' => '7846.16',
        //    'high' => '7846.16',
        //    'low' => '7846.16',
        //    'volume' => '8100.10864',
        //    'ask' => ['7847.7', '0.52882'],
        //    'bid' => ['7846.87', '3.9718']
        // }
        //
        $timestamp = $this->milliseconds();
        $timestamp = $timestamp - fmod($timestamp, 60000);
        $symbol = null;
        $marketId = $this->safe_string($ticker, 'symbol');
        if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$marketId];
        } else if ($marketId !== null) {
            list($baseId, $quoteId) = explode('/', $marketId);
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
        }
        if (($symbol === null) && ($market !== null)) {
            $symbol = $market['symbol'];
        }
        $last = $this->safe_float($ticker, 'close');
        $bid = $this->safe_value($ticker, 'bid', [null, null]);
        $ask = $this->safe_value($ticker, 'ask', [null, null]);
        return array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_float($ticker, 'high'),
            'low' => $this->safe_float($ticker, 'low'),
            'bid' => $bid[0],
            'bidVolume' => $bid[1],
            'ask' => $ask[0],
            'askVolume' => $ask[1],
            'vwap' => null,
            'open' => $this->safe_float($ticker, 'open'),
            'close' => $last,
            'last' => $last,
            'previousClose' => null, // previous day close
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_float($ticker, 'volume'),
            'quoteVolume' => null,
            'info' => $ticker,
        );
    }

    public function parse_tickers($rawTickers, $symbols = null) {
        $tickers = array();
        for ($i = 0; $i < count($rawTickers); $i++) {
            $tickers[] = $this->parse_ticker($rawTickers[$i]);
        }
        return $this->filter_by_array($tickers, 'symbol', $symbols);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->publicGetTicker (array_merge($request, $params));
        //
        // {
        //    'code' => 0,
        //    'data':
        //        {
        //            'symbol' => 'BTC/USDT',
        //            'open' => '8086.63',
        //            'close' => '7846.16',
        //            'high' => '7846.16',
        //            'low' => '7846.16',
        //            'volume' => '8100.10864',
        //            'ask' => ['7847.7', '0.52882'],
        //            'bid' => ['7846.87', '3.9718']
        //        }
        // }
        //
        return $this->parse_ticker($this->safe_value($response, 'data', array()), $market);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        if ($symbols !== null && strlen($symbols) > 0) {
            $symbol = $this->market($symbols[0])['id'];
            for ($i = 1; $i < count($symbols); $i++) {
                $market = $this->market($symbols[$i]);
                $symbol = $symbol . ',' . $market['id'];
            }
        }
        $response = $this->publicGetTicker (array_merge($request, $params));
        $tickers = $this->safe_value($response, 'data', array());
        return $this->parse_tickers($tickers, $symbols);
    }

    public function parse_ohlcv($ohlcvRecord, $market = null, $timeframe = '1m', $since = null, $limit = null) {
        //
        // {
        //    'm' => 'bar',
        //    's' => 'BTC/USDT',
        //    'data':
        //        {
        //            'i' => '1',
        //            'ts' => 1583901000000,
        //            'o' => '7924.98',
        //            'c' => '7926.80',
        //            'h' => '7926.80',
        //            'l' => '7924.98',
        //            'v' => '0.32144'
        //        }
        // }
        //
        $ohlcv = $this->safe_value($ohlcvRecord, 'data', array());
        return array(
            $this->safe_integer($ohlcv, 'ts'),
            $this->safe_float($ohlcv, 'o'),
            $this->safe_float($ohlcv, 'h'),
            $this->safe_float($ohlcv, 'l'),
            $this->safe_float($ohlcv, 'c'),
            $this->safe_float($ohlcv, 'v'),
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'interval' => $this->timeframes[$timeframe],
        );
        // if $since and $limit are not specified
        // the exchange will return just 1 last candle by default
        $duration = $this->parse_timeframe($timeframe);
        if ($since !== null) {
            $request['from'] = $since;
            if ($limit !== null) {
                $request['to'] = $this->sum($since, $limit * $duration * 1000, 1);
            }
        } else if ($limit !== null) {
            $request['to'] = $this->milliseconds();
            $request['from'] = $request['to'] - $limit * $duration * 1000 - 1;
        }
        $response = $this->publicGetBarhist (array_merge($request, $params));
        return $this->parse_ohlcvs($this->safe_value($response, 'data', array()), $market, $timeframe, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        //
        // public fetchTrades
        //
        //     {
        //         "p" => "13.75", // $price
        //         "q" => "6.68", // quantity
        //         "ts" => 1528988084944, // $timestamp
        //         "bm" => False, // if true, the buyer is the $market maker, we only use this field to "define the $side" of a public $trade
        //     }
        //
        // privateGetCashOrderStatus / privateGetMarginOrderStatus / privateGetFuturesOrderStatus
        //
        // {
        //    'seqNum' => 4208248561,
        //    'orderId' => 'r170adcc717eU123456789bbtmabc3P',
        //    'symbol' => 'BTMX/USDT',
        //    'orderType' => 'Limit',
        //    'lastExecTime' => 1583463823205,
        //    'price' => '0.06043',
        //    'orderQty' => '100',
        //    'side' => 'Buy',
        //    'status' => 'Filled',
        //    'avgPx' => '0.06043',
        //    'cumFilledQty' => '100',
        //    'stopPrice' => '',
        //    'errorCode' => '',
        //    'cumFee' => '0.006043',
        //    'feeAsset' => 'USDT',
        //    'execInst' => 'NULL_VAL'
        // }
        //
        $timestamp = $this->safe_integer($trade, 'ts');
        $price = $this->safe_float($trade, 'price') || $this->safe_float($trade, 'p');
        $amount = $this->safe_float($trade, 'orderQty') || $this->safe_float($trade, 'q');
        $cost = null;
        if (($price !== null) && ($amount !== null)) {
            $cost = $price * $amount;
        }
        $buyerIsMaker = $this->safe_value($trade, 'bm');
        $makerOrTaker = null;
        if ($buyerIsMaker !== null) {
            if ($buyerIsMaker) {
                $makerOrTaker = 'maker';
            } else {
                $makerOrTaker = 'taker';
            }
        }
        $symbol = null;
        $marketId = $this->safe_string($trade, 's');
        if ($marketId !== null) {
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
            } else {
                list($baseId, $quoteId) = explode('/', $market);
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = $base . '/' . $quote;
            }
        }
        if (($symbol === null) && ($market !== null)) {
            $symbol = $market['symbol'];
        }
        $fee = null;
        $feeCost = $this->safe_float($trade, 'cumFee');
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'feeAsset');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        $orderId = $this->safe_string($trade, 'orderId');
        $side = $this->safe_string_lower($trade, 'side');
        if (($side === null) && ($buyerIsMaker !== null)) {
            $side = $buyerIsMaker ? 'buy' : 'sell';
        }
        $type = $this->safe_string_lower($trade, 'orderType');
        return array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => null,
            'order' => $orderId,
            'type' => $type,
            'takerOrMaker' => $makerOrTaker,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        );
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['n'] = $limit; // currently limited to 100 or fewer
        }
        $response = $this->publicGetTrades (array_merge($request, $params));
        //
        //    {
        //        'code' => 0,
        //        'data':
        //            {
        //                'm' => 'trades',
        //                'symbol' => 'BTC/USDT',
        //                'data' => [array('p' => '7812.61',
        //                        'q' => '0.01998',
        //                        'ts' => 1583760687790,
        //                        'bm' => False, # if True, the buyer is the $market maker
        //                        'seqnum' => 72057603463162642)]
        //              }
        //     }
        //
        $records = $this->safe_value($response, 'data', array());
        $trades = $this->safe_value($records, 'data', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'PendingNew' => 'open',
            'New' => 'open',
            'PartiallyFilled' => 'open',
            'Filled' => 'closed',
            'Canceled' => 'canceled',
            'Rejected' => 'rejected',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        //
        // createOrder
        //
        // {
        //    'symbol' => 'BTC/USDT',
        //    'orderType' => 'Limit',
        //    'action' => 'new',
        //    'timestamp' => 1583812256973,
        //    'id' => '0e602eb4337d4aebbe3c438f6cc41aee',
        //    'orderId' => 'a170c29124378418641348f6cc41aee'
        // }
        //
        // fetchOrder, fetchOpenOrders, fetchClosedOrders
        //
        // {
        //    'avgPx' => '9126.75',
        //    'cumFee' => '0.002738025',
        //    'cumFilledQty' => '0.0005',
        //    'errorCode' => '',
        //    'execInst' => 'NULL_VAL',
        //    'feeAsset' => 'USDT',
        //    'lastExecTime' => 1583443804918,
        //    'orderId' => 'r170ac9b032cU9490877774sbtcpeAAb',
        //    'orderQty' => '0.0005',
        //    'orderType' => 'Market',
        //    'price' => '8853',
        //    'seqNum' => 4204789616,
        //    'side' => 'Sell',
        //    'status' => 'Filled',
        //    'stopPrice' => '',
        //    'symbol' => 'BTC-PERP'
        // }
        //
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $marketId = $this->safe_string($order, 'symbol');
        $symbol = null;
        if ($marketId !== null) {
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
            } else {
                list($baseId, $quoteId) = explode('/', $marketId);
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = $base . '/' . $quote;
            }
        }
        if (($symbol === null) && ($market !== null)) {
            $symbol = $market['symbol'];
        }
        $timestamp = $this->safe_integer($order, 'lastExecTime') || $this->safe_integer($order, 'timestamp');
        $price = $this->safe_float($order, 'price');
        $amount = $this->safe_float($order, 'orderQty');
        $avgFillPx = $this->safe_float($order, 'avgPx');
        $filled = $this->safe_float($order, 'cumFilledQty');
        $remaining = ($amount || 0) - ($filled || 0);
        if ($remaining < 0) {
            $remaining = 0;
        }
        if ($symbol !== null) {
            $remaining = $this->amount_to_precision($symbol, $remaining);
        }
        $cost = ($avgFillPx || 0) * ($filled || 0);
        $id = $this->safe_string($order, 'orderId');
        $type = $this->safe_string($order, 'orderType');
        if ($type !== null) {
            $type = strtolower($type);
            if ($type === 'market') {
                if ($price === 0.0) {
                    if (($cost !== null) && ($filled !== null)) {
                        if (($cost > 0) && ($filled > 0)) {
                            $price = $cost / $filled;
                        }
                    }
                }
            }
        }
        $side = $this->safe_string_lower($order, 'side');
        $fee = array(
            'cost' => $this->safe_float($order, 'cumFee'),
            'currency' => $this->safe_string($order, 'feeAsset'),
        );
        $clientOrderId = $id;
        return array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'average' => $avgFillPx,
            'filled' => $filled,
            'remaining' => $remaining,
            'status' => $status,
            'fee' => $fee,
            'trades' => null,
        );
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $this->load_accounts();
        $market = $this->market($symbol);
        $request = array(
            'id' => $this->coid(), // optional, a unique identifier of length 32
            // 'time' => $this->milliseconds(), // milliseconds since UNIX epoch in UTC, this is filled in the private section of the sign() $method below
            'symbol' => $market['id'],
            'orderPrice' => $this->price_to_precision($symbol, $price || 0), // optional, limit $price of the order. This field is required for limit orders and stop limit orders
            'stopPrice' => $this->price_to_precision($symbol, $this->safe_value($params, 'stopPrice', 0.0)), // optional, stopPrice of the order. This field is required for stop_market orders and stop limit orders
            'orderQty' => $this->amount_to_precision($symbol, $amount),
            'orderType' => $type, // order $type, you shall specify one of the following => "limit", "$market", "stop_market", "stop_limit"
            'side' => $side, // "buy" or "sell"
            'postOnly' => $this->safe_value($params, 'postOnly', false), // optional, if true, the order will either be posted to the limit order book or be cancelled, i.e. the order cannot take liquidity, default is false
            'timeInForce' => $this->safe_string($params, 'timeInForce', 'GTC'), // optional, supports "GTC" good-till-canceled, "IOC" immediate-or-cancel, and "FOK" for fill-or-kill
        );
        if (($type === 'limit') || ($type === 'stop_limit')) {
            $request['orderPrice'] = $this->price_to_precision($symbol, $price);
        }
        $method = 'privatePost' . $this->get_account($params) . 'Order';
        $response = $this->$method (array_merge($request, $params));
        //
        // {
        //  'code' => 0,
        //  'data' => {
        //              'ac' => 'CASH',
        //              'accountId' => 'hongyu.wang',
        //              'action' => 'place-order',
        //              'info' => array(
        //                   'id' => 'JhAAjOoTY6EINXC8QcOL18HoXw89FU0u',
        //                   'orderId' => 'a170d000346b5450276356oXw89FU0u',
        //                   'orderType' => 'Limit',
        //                   'symbol' => 'BTMX/USDT',
        //                   'timestamp' => 1584037640014
        //                  ),
        //              'status' => 'Ack'
        //          }
        // }
        //
        $data = $this->safe_value($response, 'data', array());
        $info = array_merge($this->safe_value($data, 'info'), array( 'status' => null ));
        return $this->parse_order($info, $market);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $this->load_accounts();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request = array(
            'orderId' => $id,
        );
        $accounts = null;
        if (is_array($params) && array_key_exists('account', $params)) {
            $accounts = array( $this->safe_value($params, 'account') );
        } else {
            $accounts = $this->get_valid_accounts();
        }
        $response = null;
        for ($i = 0; $i < count($accounts); $i++) {
            if ($response === null) {
                try {
                    $account = $this->get_account(array( 'account' => $accounts[$i] ));
                    $method = 'privateGet' . $account . 'OrderStatus';
                    $response = $this->$method (array_merge($request, $params));
                } catch (Exception $error) {
                    // log $error
                    $response = null;
                }
            }
        }
        //
        //  {
        //      'code' => 0,
        //      'accountId' => 'ABCDEFGHIJKLMNOPQRSTUVWXYZABC',
        //      'ac' => 'CASH',
        //      'data' => {
        //          'seqNum' => 4208248561,
        //          'orderId' => 'r170adcc717eU123456789bbtmabc3P',
        //          'symbol' => 'BTMX/USDT',
        //          'orderType' => 'Limit',
        //          'lastExecTime' => 1583463823205,
        //          'price' => '0.06043',
        //          'orderQty' => '100',
        //          'side' => 'Buy',
        //          'status' => 'Filled',
        //          'avgPx' => '0.06043',
        //          'cumFilledQty' => '100',
        //          'stopPrice' => '',
        //          'errorCode' => '',
        //          'cumFee' => '0.006043',
        //          'feeAsset' => 'USDT',
        //          'execInst' => 'NULL_VAL'
        //          }
        // }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_order($data, $market);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $this->load_accounts();
        $market = null;
        $request = array(
            // 'symbol' => 'ETH/BTC', // optional
            // 'category' => 'CASH', // optional, string
            // 'orderType' => 'Market', // optional, string
            // 'page' => 1, // optional, integer type, starts at 1
            // 'pageSize' => 100, // optional, integer type
            // 'side' => 'buy', // or 'sell', optional, case insensitive.
            // 'startTime' => 1566091628227, // optional, integer milliseconds $since UNIX epoch representing the start of the range
            // 'endTime' => 1566091628227, // optional, integer milliseconds $since UNIX epoch representing the end of the range
            // 'status' => 'Filled', // optional, can only be one of "Filled", "Canceled", "Rejected"
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['n'] = $limit; // default 15, max 50
        }
        $request['executedOnly'] = $this->safe_value($params, 'executedOnly', false);
        $method = 'privateGet' . $this->get_account($params) . 'OrderHistCurrent';
        $response = $this->$method (array_merge($request, $params));
        //
        // {
        //    'code' => 0,
        //    'accountId' => 'test1@xxxxx.io',
        //    'ac' => 'CASH',
        //    'data' => [
        //        array(
        //            'seqNum' => 30181890,
        //            'orderId' => 'a170c4f6cae084186413483b0e984fe',
        //            'symbol' => 'BTC/USDT',
        //            'orderType' => 'Limit',
        //            'lastExecTime' => 1583852473185,
        //            'price' => '8500',
        //            'orderQty' => '0.01',
        //            'side' => 'Buy',
        //            'status' => 'Filled',
        //            'avgPx' => '8032.04',
        //            'cumFilledQty' => '0.01',
        //            'stopPrice' => '',
        //            'errorCode' => '',
        //            'cumFee' => '0.065862728',
        //            'feeAsset' => 'USDT',
        //            'execInst' => 'NULL_VAL'
        //        )]
        // }
        //
        $orders = $this->safe_value($response, 'data', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $this->load_accounts();
        $market = null;
        $request = array(
            // 'symbol' => 'symbol'  optional
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        $method = 'privateGet' . $this->get_account($params) . 'OrderOpen';
        $response = $this->$method (array_merge($request, $params));
        //
        // {
        //    'code' => 0,
        //    'accountId' => 'MPXFNEYEJIJ93CREXT3LTCIDIJPCFNIX',
        //    'ac' => 'CASH',
        //    'data':
        //        [array(
        //            'seqNum' => 4305977824,
        //            'orderId' => 'a170c9e191a7U9490877774397007e73',
        //            'symbol' => 'BTMX/USDT',
        //            'orderType' => 'Limit',
        //            'lastExecTime' => 1583934968446,
        //            'price' => '0.045',
        //            'orderQty' => '200',
        //            'side' => 'Buy',
        //            'status' => 'New',
        //            'avgPx' => '0',
        //            'cumFilledQty' => '0',
        //            'stopPrice' => '',
        //            'errorCode' => '',
        //            'cumFee' => '0',
        //            'feeAsset' => 'USDT',
        //            'execInst' => 'NULL_VAL'
        //        )]
        // }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $this->load_accounts();
        $market = null;
        $request = array(
            // 'symbol' => 'ETH/BTC', // optional
            // 'category' => 'CASH'/'MARGIN'/"FUTURES', // optional, string
            // 'orderType' => 'Market', // optional, string
            // 'page' => 1, // optional, integer type, starts at 1
            // 'pageSize' => 100, // optional, integer type
            // 'side' => 'buy', // or 'sell', optional, case insensitive.
            // 'startTime' => 1566091628227, // optional, integer milliseconds $since UNIX epoch representing the start of the range
            // 'endTime' => 1566091628227, // optional, integer milliseconds $since UNIX epoch representing the end of the range
            // 'status' => 'Filled', // optional, can only be one of "Filled", "Canceled", "Rejected"
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['n'] = $limit; // default 15, max 50
        }
        $response = $this->privateGetOrderHist (array_merge($request, $params));
        //
        // {
        //    'code' => 0,
        //    'data':
        //        {
        //            'page' => 1,
        //            'pageSize' => 20,
        //            'limit' => 500,
        //            'hasNext' => True,
        //            'data' => array(
        //                {
        //                    'ac' => 'CASH',
        //                    'accountId' => 'ABCDEFGHIJKLMOPQRSTUVWXYZABC',
        //                    'avgPx' => '0',
        //                    'cumFee' => '0',
        //                    'cumQty' => '0',
        //                    'errorCode' => 'NULL_VAL',
        //                    'feeAsset' => 'USDT',
        //                    'lastExecTime' => 1583894311925,
        //                    'orderId' => 'r170c77528bdU9490877774bbtcu9DwL',
        //                    'orderQty' => '0.001', 'orderType' => 'Limit',
        //                    'price' => '7912.88',
        //                    'sendingTime' => 1583894310880,
        //                    'seqNum' => 4297339552,
        //                    'side' => 'Buy',
        //                    'status' => 'Canceled',
        //                    'stopPrice' => '',
        //                    'symbol' => 'BTC/USDT',
        //                    'execInst' => 'NULL_VAL'
        //                }
        //            )
        //        }
        // }
        //
        $data = $this->safe_value($response, 'data', array());
        $orders = $this->safe_value($data, 'data', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder requires a $symbol argument');
        }
        $this->load_markets();
        $this->load_accounts();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'id' => $this->coid(), // optional
            'orderId' => $id,
            // 'time' => $this->milliseconds(), // this is filled in the private section of the sign() $method below
        );
        $method = 'privateDelete' . $this->get_account($params) . 'Order';
        $response = $this->$method (array_merge($request, $params));
        //
        // {
        //    'code' => 0,
        //    'data':
        //        {
        //            'accountId' => 'test1@xxxxx.io',
        //            'ac' => 'CASH',
        //            'action' => 'cancel-order',
        //            'status' => 'Ack',
        //            'info' => {
        //                'symbol' => 'BTC/USDT',
        //                'orderType' => '',
        //                'timestamp' => 1583868590663,
        //                'id' => 'de4f5a7c5df2433cbe427da14d8f84d5',
        //                'orderId' => 'a170c5136edb8418641348575f38457'}
        //        }
        // }
        //
        $order = $this->safe_value($this->safe_value($response, 'data', array()), 'info', array());
        $order['status'] = null;
        return $this->parse_order($order);
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        $this->load_markets();
        $this->load_accounts();
        $request = array(
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id']; // optional
        }
        $method = 'privateDelete' . $this->get_account($params) . 'OrderAll';
        $response = $this->$method (array_merge($request, $params));
        //
        // {
        //    'code' => 0,
        //    'data':
        //        {
        //            'accountId' => 'test1@dengpan.io',
        //            'ac' => 'CASH',
        //            'action' => 'cancel-all',
        //            'status' => 'Ack',
        //            'info':
        //                {
        //                    'symbol' => '',
        //                    'orderType' => 'NULL_VAL',
        //                    'timestamp' => 1584057856765,
        //                    'id' => '',
        //                    'orderId' => ''
        //                }
        //             }
        //    }
        // }
        //
        $order = $this->safe_value($this->safe_value($response, 'data', array()), 'info', array());
        $order['status'] = null;
        $order['orderType'] = null;
        $order['symbol'] = $symbol;
        return $this->parse_order($order);
    }

    public function coid() {
        $uuid = $this->uuid();
        $parts = explode('-', $uuid);
        $clientOrderId = implode('', $parts);
        $coid = mb_substr($clientOrderId, 0, 32 - 0);
        return $coid;
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $this->load_markets();
        $this->load_accounts();
        $currency = $this->currency($code);
        $request = array(
            'requestId' => $this->coid(),
            // 'time' => $this->milliseconds(), // this is filled in the private section of the sign() method below
            'asset' => $currency['id'],
            'isCommonApi' => true, // not from $request
        );
        $response = $this->privateGetWalletDepositAddress (array_merge($request, $params));
        //
        //
        // {
        //    'code' => 0,
        //    'data':
        //        {
        //            'asset' => 'BTC',
        //            'assetName' => 'Bitcoin',
        //            'address':
        //                array(
        //                    {
        //                        'address' => '3P5e8M6nQaGPB6zYJ447uGJKCJN2ZkEDLB',
        //                        'destTag' => '',
        //                        'tagType' => '',
        //                        'tagId' => '',
        //                        'chainName' => 'Bitcoin',
        //                        'numConfirmations' => 3,
        //                        'withdrawalFee' => 0.0005,
        //                        'nativeScale' => 8,
        //                        'tips' => array()
        //                    }
        //                )
        //        }
        // }
        //
        $data = $this->safe_value($response, 'data', array());
        $addressData = $this->safe_value($data, 'address', array());
        if (gettype($addressData) === 'array' && count(array_filter(array_keys($addressData), 'is_string')) == 0) {
            $addressData = $this->safe_value($addressData, 0, array());
        }
        $address = $this->safe_string($addressData, 'address');
        $tag = $this->safe_string($addressData, 'destTag');
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'info' => $response,
        );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = '/api/pro/' . $this->version . '/' . $this->implode_params($path, $params);
        $query = $this->omit($params, $this->extract_params($path));
        if ($api === 'public') {
            if ($query) {
                $url .= '?' . $this->urlencode($query);
            }
        } else {
            $this->check_required_credentials();
            if (!$this->safe_value($params, 'isCommonApi', false)) {
                $accountGroup = $this->safe_string($this->options, 'accountGroup');
                if ($accountGroup === null) {
                    if ($this->accounts !== null) {
                        $accountGroup = $this->accounts[0]['id'];
                    }
                }
                if ($accountGroup !== null) {
                    $url = '/' . $accountGroup . $url;
                }
            }
            $query['time'] = (string) $this->milliseconds();
            $auth = $query['time'] . '+' . str_replace('/{orderId}', '', $path); // fix sign error
            $headers = array(
                'x-$auth-key' => $this->apiKey,
                'x-$auth-timestamp' => $query['time'],
                'Content-Type' => 'application/json',
            );
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256', 'base64');
            $headers['x-$auth-signature'] = $this->decode($signature);
            if ($method === 'GET') {
                if ($query) {
                    $url .= '?' . $this->urlencode($query);
                }
            } else {
                $body = $this->json($query);
            }
        }
        $url = $this->urls['api'] . $url;
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return; // fallback to default $error handler
        }
        //
        //     array("$code":2100,"$message":"ApiKeyFailure")
        //     array('code' => 6010, 'message' => 'Not enough balance.')
        //     array('code' => 60060, 'message' => 'The order is already filled or canceled.')
        //
        $code = $this->safe_string($response, 'code');
        $message = $this->safe_string($response, 'message');
        $error = ($code !== null) && ($code !== '0');
        if ($error || ($message !== null)) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        }
    }
}
